"use strict";

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _templateObject = _taggedTemplateLiteral(["<style>\n\t\t\t\t          :host{\n\t\t\t\t              display: flex;\n\t\t\t\t              flex-direction: column;\n\t\t\t\t              flex-wrap: nowrap;\n\t\t\t\t          }\n\t\t\t\t        </style>\n\t\t\t\t        <slot></slot>\n\t\t\t\t      "], ["<style>\n\t\t\t\t          :host{\n\t\t\t\t              display: flex;\n\t\t\t\t              flex-direction: column;\n\t\t\t\t              flex-wrap: nowrap;\n\t\t\t\t          }\n\t\t\t\t        </style>\n\t\t\t\t        <slot></slot>\n\t\t\t\t      "]),
    _templateObject2 = _taggedTemplateLiteral(["<style>\n\t\t\t\t                :host{\n\t\t\t\t                    display: inline-block;\n\t\t\t\t                    flex: 0 1 auto;\n\t\t\t\t                }\n\t\t\t\t                :host(:not([flexible])){\n\t\t\t\t                    box-sizing: border-box;\n\t\t\t\t                    width: 100%;\n\t\t\t\t                    min-height: 100vh;\n\t\t\t\t                }\n\t\t\t\t                :host([flexible]){\n\t\t\t\t                    margin-left: 50%;\n\t\t\t\t                    transform: translateX(-50%);\n\t\t\t\t                }\n\t\t\t\t            </style>\n\t\t\t\t            <slot></slot>\n\t\t\t\t      "], ["<style>\n\t\t\t\t                :host{\n\t\t\t\t                    display: inline-block;\n\t\t\t\t                    flex: 0 1 auto;\n\t\t\t\t                }\n\t\t\t\t                :host(:not([flexible])){\n\t\t\t\t                    box-sizing: border-box;\n\t\t\t\t                    width: 100%;\n\t\t\t\t                    min-height: 100vh;\n\t\t\t\t                }\n\t\t\t\t                :host([flexible]){\n\t\t\t\t                    margin-left: 50%;\n\t\t\t\t                    transform: translateX(-50%);\n\t\t\t\t                }\n\t\t\t\t            </style>\n\t\t\t\t            <slot></slot>\n\t\t\t\t      "]);

function _taggedTemplateLiteral(strings, raw) { return Object.freeze(Object.defineProperties(strings, { raw: { value: Object.freeze(raw) } })); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _CustomElement() {
	return Reflect.construct(HTMLElement, [], this.__proto__.constructor);
}

;
Object.setPrototypeOf(_CustomElement.prototype, HTMLElement.prototype);
Object.setPrototypeOf(_CustomElement, HTMLElement);
// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var _resolve,
	    getRequire,
	    wmRequire,
	    notFoundError,
	    findFile,
	    extensions = { ".js": [], ".json": [], ".css": [], ".html": [] },
	    envRequire = typeof require === 'function' ? require : null;

	notFoundError = function notFoundError(path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function findFile(scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; ext = extensions[extName][i]; ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	_resolve = function resolve(scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split('/');
		name = path.pop();
		if (name === '.' || name === '..') {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || dir === '.') continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && typeof scope[name] !== 'function') {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if (state !== 2 && _typeof(scope[name]) === 'object') {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if (state !== 1 && scope[':mainpath:']) {
				return _resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return _resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function wmRequire(scope, tree, fullPath, id) {
		var name,
		    path = fullPath,
		    t = fullPath.charAt(0),
		    state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return _resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function getRequire(scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"page-sections": {
		"src": {
			"make-template.js": function makeTemplateJs(exports, module, require) {
				var makeTemplate = function makeTemplate(strings) {
					var html = '';

					for (var _len = arguments.length, substs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
						substs[_key - 1] = arguments[_key];
					}

					for (var i = 0; i < substs.length; i++) {
						html += strings[i];
						html += substs[i];
					}
					html += strings[strings.length - 1];
					var template = document.createElement('template');
					template.innerHTML = html;
					return template;
				};
				/**
     * export make template function
     */
				module.exports = makeTemplate;
			},
			"page-section-container.js": function pageSectionContainerJs(exports, module, require) {
				/* global HTMLElement */
				(function () {
					var makeTemplate = require('./make-template');

					var PageSections = function (_CustomElement2) {
						_inherits(PageSections, _CustomElement2);

						function PageSections() {
							_classCallCheck(this, PageSections);

							var _this = _possibleConstructorReturn(this, (PageSections.__proto__ || Object.getPrototypeOf(PageSections)).call(this));
							// needs to be called first


							var template = makeTemplate(_templateObject);
							// set sections initial active state to false
							_this._active = false;
							// create shadowRoot
							var shadowRoot = _this.attachShadow({ mode: 'open' });
							// check if polyfill is used
							if (typeof ShadyCSS !== 'undefined') {
								ShadyCSS.prepareTemplate(template, 'page-sections'); // eslint-disable-line no-undef
								// add content to shadowRoot & apply css polyfill
								ShadyCSS.applyStyle(_this); // eslint-disable-line no-undef
							}
							shadowRoot.appendChild(document.importNode(template.content, true));
							return _this;
						}
						/**
       * get active state of parent container
       * @method active
       * @return {Boolean}
       */


						_createClass(PageSections, [{
							key: "connectedCallback",
							value: function connectedCallback() {
								this._scrollEvent = this._scrollEvent.bind(this);
								// wrap sections
								window.addEventListener('scroll', this._scrollEvent); // bing this, so that it refers to custom element instead of window
							}
						}, {
							key: "_scrollEvent",
							value: function _scrollEvent(e) {
								clearTimeout(this._scrollEvent.fn);
								this._scrollEvent.fn = setTimeout(function () {
									this.setActive();
								}.bind(this), 10);
							}
							/**
        * check if section wrapper is in viewport
        */

						}, {
							key: "_setActiveState",

							/**
        * set _active property & add/remove active attr
        */
							value: function _setActiveState(state) {
								// set _active property
								this._active = state === true;
								// add or remove active attribute
								if (this._active) {
									this.setAttribute('active', '');
									return;
								} else {
									this.removeAttribute('active');
								}
							}
							// check if a child element is in view and set it to active

						}, {
							key: "setActive",
							value: function setActive() {
								this._setActiveState(this._inView);
								// if element is in view, active children
								if (this._inView) {
									// Get all child elements and activate visible ones
									// stop once an inactive item follows an active item
									var elements = this.querySelectorAll('page-section');
									for (var i = 0; elements.length > i; ++i) {
										elements[i].setActive();
										// abort if current element is NOT in view, but previous was in view
										if (i > 0 && elements[i].active === false && elements[i - 1].active === true) {
											return;
										}
									}
									return;
								}
							}
						}, {
							key: "active",
							get: function get() {
								return this._active;
							}
						}, {
							key: "_inView",
							get: function get() {
								return this.getBoundingClientRect().bottom > 0;
							}
						}]);

						return PageSections;
					}(_CustomElement);

					module.exports = PageSections;
					// window.customElements.define('page-sections', PageSections)
				})();
			},
			"page-section.js": function pageSectionJs(exports, module, require) {
				/* global HTMLElement Event */
				(function () {
					var makeTemplate = require('./make-template');

					var PageSection = function (_CustomElement3) {
						_inherits(PageSection, _CustomElement3);

						function PageSection() {
							_classCallCheck(this, PageSection);

							var _this2 = _possibleConstructorReturn(this, (PageSection.__proto__ || Object.getPrototypeOf(PageSection)).call(this));
							// If you define a ctor, always call super() first!
							// This is specific to CE and required by the spec.


							var item = makeTemplate(_templateObject2);
							//   ShadyCSS.prepareTemplate(item, 'page-section') // eslint-disable-line no-undef
							// by default _active is false
							_this2._active = false;
							// Attach a shadow root to the element.
							var shadowRoot = _this2.attachShadow({ mode: 'open' });
							// add content to shadowRoot & apply css polyfill
							//   ShadyCSS.applyStyle(this) // eslint-disable-line no-undef
							shadowRoot.appendChild(document.importNode(item.content, true));
							return _this2;
						}
						/**
       * get active state of individual section
       * @method active
       * @return {Boolean}
       */


						_createClass(PageSection, [{
							key: "connectedCallback",

							/**
        * When element is added to DOM
        */
							value: function connectedCallback() {
								// initialize activated state
								this.setActive();
							}
							/**
        * set _active property & add/remove active attr
        */

						}, {
							key: "_setActiveState",
							value: function _setActiveState(state) {
								if (this._active === state) {
									return;
								}
								// set _active property
								this._active = state === true;
								// add or remove active attribute
								if (this._active) {
									this.setAttribute('active', '');
									return;
								} else {
									this.removeAttribute('active');
								}
							}
							/**
        * set active if in viewport or unactive if not
        */

						}, {
							key: "setActive",
							value: function setActive() {
								this._setActiveState(this._inView);

								if (this._inView) {
									if (this.active === false) {
										// set attributes
										this.setAttribute('active', '');
										this._active = true;
										// Dispatch the event.
										this.dispatchEvent(new Event('activated'));
									}
									// return true
									return true;
								}
								// set element to unactive
								if (this.active === true) {
									// set attributes
									this.removeAttribute('active');
									this._active = false;
									// Dispatch the event.
									this.dispatchEvent(new Event('deactivated'));
								}
							}
						}, {
							key: "active",
							get: function get() {
								return this._active;
							}
							/**
        * check if element is in view
        */

						}, {
							key: "_inView",
							get: function get() {
								// get elements bounding box
								var box = this.getBoundingClientRect();
								// check if element is in view
								if (box.top >= 0 && (box.top < window.innerHeight * 0.5 || box.bottom <= window.innerHeight) || box.top < window.innerHeight * 0.5 && box.bottom > window.innerHeight * 0.5 || box.top < window.innerHeight - box.height / 1.25) {
									return true;
								}
							}
						}]);

						return PageSection;
					}(_CustomElement);

					module.exports = PageSection;
					// window.customElements.define('page-section', PageSectionItem)
				})();
			},
			"page-sections.js": function pageSectionsJs(exports, module, require) {
				(function () {
					var PageSectionContainer = require('./page-section-container');
					var PageSection = require('./page-section');

					window.customElements.define('page-sections', PageSectionContainer);
					window.customElements.define('page-section', PageSection);
				})();
			}
		}
	}
})("page-sections/src/page-sections");
//# sourceMappingURL=page-sections.js.map
